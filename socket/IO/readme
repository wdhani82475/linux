


3 原理：利用单线程，实现为多个客户端服务。
4 目的：节省资源，提高效率,提高服务器的能力
5 
6 一个人管一架飞机-------一个人管多架飞机。
7 
8  起飞--出港口======抢占这些资源     ========公共资源（公平）
9 
10  每一个航线ocket流，每一个航空管理员看成服务代码
11 
12 方式：
13     1.多进程的并发模型（创建多个线程或进程）
14     2.I/O多路复用，---单个线程，通过记录和跟踪socket(i/o流)状态，来同时管理多个i/o流。
哪个客户端准备好了（状态），服务器就给他提供服务。提供反向服务。    客户端主动提出请求,然后客户端给提供服务.                     

实现：为5个服务，也可以为新来的服务

select:#include<sys/select.h> 
  select //fun
//define
FD_SET()24             FD_ZERO()//init
		FD_CAL()；
		FD_ISSET();

		fd_set;//反射函数  cli把数据发送给ser,ser把数据发送给cli.
				
		清零 ----设置套接字
		{
			1.sockSer				    	》select  轮询机制进行处理
			最大描述：unlong int ar[32]  -------4*4*32=1024位
	返回	2.客户端   清零---》集合------》poll------>>判断
		}


		poll
				#include<poll.h>   struct pooled 结构体

		epoll #include<sys/epoll.h>



